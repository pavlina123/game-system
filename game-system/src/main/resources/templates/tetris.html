<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–¢–µ—Ç—Ä–∏—Å - üëæ GRID BREAKER</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        body {
            font-family: 'Orbitron', sans-serif;
            background: linear-gradient(135deg, #0a0a1a, #200020); /* –ì–ª—É–±–æ–∫–∏–π —Ç–µ–º–Ω—ã–π —Ñ–æ–Ω */
            color: #00ffff;
            text-align: center;
            padding: 20px;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #ff00ff;
            margin-bottom: 10px;
            text-shadow: 0 0 15px rgba(255, 0, 255, 0.8);
            letter-spacing: 3px;
        }
        #game-area {
            width: 300px;
            height: 600px;
            background-color: #000000;
            margin: 20px auto;
            border: 3px solid #00ffff; /* –¶–∏–∞–Ω–æ–≤–∞—è —Ä–∞–º–∫–∞ */
            border-radius: 5px;
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6);
            position: relative;
        }
        #tetris-canvas {
            background: transparent; /* –°–µ—Ç–∫–∞ –±—É–¥–µ—Ç –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–∞ –≤ JS */
        }

        #start-button, #play-button {
            background: #ff00ff; /* –ü—É—Ä–ø—É—Ä–Ω–∞—è –∫–Ω–æ–ø–∫–∞ */
            color: white;
            padding: 15px 30px;
            font-size: 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 15px;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.7);
        }
        #start-button:hover, #play-button:hover {
            background: #ff40ff;
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(255, 64, 255, 1);
        }
        #status {
            margin-top: 10px;
            padding: 10px;
            font-size: 16px;
            color: #fff;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #00ffff;
            border-radius: 5px;
            width: 280px;
            text-shadow: 0 0 8px #00ffff;
        }
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #ff00ff;
            font-size: 36px;
            text-shadow: 0 0 15px #ff00ff;
            font-family: 'Orbitron', sans-serif;
        }
        .restart-button {
            background: #00ffff; /* –¶–∏–∞–Ω–æ–≤–∞—è –∫–Ω–æ–ø–∫–∞ */
            color: #0d0d1a;
            border: none;
            padding: 12px 25px;
            font-size: 18px;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 5px;
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.7);
        }
    </style>
</head>
<body>

<h1>TETRIS // GRID BREAKER üëæ</h1>

<div id="game-area">
    <canvas id="tetris-canvas" width="300" height="600" style="display:none;"></canvas>
    <p id="placeholder-text">INITIATE ARDUINO PROTOCOL</p>
    <div class="game-over" id="game-over">
        <div>CORE OVERLOAD</div>
        <div id="final-score" style="font-size: 24px; margin-top: 10px;"></div>
        <button class="restart-button" id="restart-button">RE-SYNCHRONIZE</button>
    </div>
</div>

<button id="start-button">CONNECT ARDUINO INTERFACE</button>
<button id="play-button" style="display:none;">START SIMULATION</button>

<div id="status">STATUS: AWAITING CONNECTION</div>

<script>
    // --- üé∂ –ê–£–î–ò–û –ö–û–ù–¢–ï–ö–°–¢ üé∂ ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    function playMoveSound() {
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        osc.type = 'sine';
        osc.frequency.setValueAtTime(300, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);

        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.05);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.05);

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –Ω–∞ –∞—Ä–¥—É–∏–Ω–æ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∑–≤—É–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è
        sendMoveSoundToArduino();
    }

    function playRotateSound() {
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.15, audioCtx.currentTime);

        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.08);

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –Ω–∞ –∞—Ä–¥—É–∏–Ω–æ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∑–≤—É–∫–∞ –≤—Ä–∞—â–µ–Ω–∏—è
        sendRotateSoundToArduino();
    }

    function playDropSound() {
        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        osc.type = 'sine';
        osc.frequency.setValueAtTime(200, audioCtx.currentTime);
        gainNode.gain.setValueAtTime(0.2, audioCtx.currentTime);

        gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.1);

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –Ω–∞ –∞—Ä–¥—É–∏–Ω–æ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∑–≤—É–∫–∞ –ø–∞–¥–µ–Ω–∏—è
        sendDropSoundToArduino();
    }

    function playLineClearSound(linesCleared) {
        const notes = [500, 600, 700, 800];
        const duration = 0.1;
        let time = audioCtx.currentTime;

        // –í–æ—Å–ø—Ä–æ–∏–∑–≤–æ–¥–∏–º –Ω–æ—Ç—ã –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ—á–∏—â–µ–Ω–Ω—ã—Ö –ª–∏–Ω–∏–π
        for (let i = 0; i < Math.min(linesCleared, 4); i++) {
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            osc.type = 'square';

            gainNode.gain.setValueAtTime(0.02, time + i * duration * 1.2);
            gainNode.gain.linearRampToValueAtTime(0.2, time + i * duration * 1.2 + 0.05);
            gainNode.gain.linearRampToValueAtTime(0.001, time + (i * duration * 1.2) + duration);

            osc.frequency.setValueAtTime(notes[i], time + i * duration * 1.2);
            osc.start(time + i * duration * 1.2);
            osc.stop(time + (i * duration * 1.2) + duration);
        }

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –Ω–∞ –∞—Ä–¥—É–∏–Ω–æ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∑–≤—É–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –ª–∏–Ω–∏–π
        sendLineClearSoundToArduino(linesCleared);
    }

    function playLevelUpSound() {
        const notes = [400, 600, 800, 1000];
        const duration = 0.15;
        let time = audioCtx.currentTime;

        notes.forEach((freq, index) => {
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            osc.type = 'triangle';

            gainNode.gain.setValueAtTime(0.02, time + index * duration * 1.1);
            gainNode.gain.linearRampToValueAtTime(0.3, time + index * duration * 1.1 + 0.05);
            gainNode.gain.linearRampToValueAtTime(0.001, time + (index * duration * 1.1) + duration);

            osc.frequency.setValueAtTime(freq, time + index * duration * 1.1);
            osc.start(time + index * duration * 1.1);
            osc.stop(time + (index * duration * 1.1) + duration);
        });

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –Ω–∞ –∞—Ä–¥—É–∏–Ω–æ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∑–≤—É–∫–∞ –ø–æ–≤—ã—à–µ–Ω–∏—è —É—Ä–æ–≤–Ω—è
        sendLevelUpSoundToArduino();
    }

    function playGameOverSound() {
        const notes = [300, 250, 200, 150, 100];
        const duration = 0.25;
        let time = audioCtx.currentTime;

        notes.forEach((freq, index) => {
            const osc = audioCtx.createOscillator();
            osc.connect(audioCtx.destination);
            osc.type = 'sawtooth';

            osc.frequency.setValueAtTime(freq, time + index * duration * 1.5);
            osc.start(time + index * duration * 1.5);
            osc.stop(time + (index * duration * 1.5) + duration);
        });

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É –Ω–∞ –∞—Ä–¥—É–∏–Ω–æ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∑–≤—É–∫–∞ –ø—Ä–æ–∏–≥—Ä—ã—à–∞
        sendGameOverToArduino();
    }
    // ------------------------------------

    let port, reader, writer;
    let gameRunning = false;
    const statusDiv = document.getElementById('status');
    const canvas = document.getElementById('tetris-canvas');
    const ctx = canvas.getContext('2d');
    const playButton = document.getElementById('play-button');
    const gameOverScreen = document.getElementById('game-over');
    const finalScoreElement = document.getElementById('final-score');

    // –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã –∏–≥—Ä—ã
    const COLS = 10;
    const ROWS = 20;
    const BLOCK_SIZE = 30;
    // –¶–≤–µ—Ç–∞ Tetrominoes (–ù–µ–æ–Ω–æ–≤—ã–µ/–Ø—Ä–∫–∏–µ)
    const COLORS = [
        null,
        '#FF33CC', // I (–ü—É—Ä–ø—É—Ä–Ω—ã–π)
        '#33CCFF', // J (–ì–æ–ª—É–±–æ–π)
        '#CCFF33', // L (–õ–∞–π–º–æ–≤—ã–π)
        '#FFCC33', // O (–û—Ä–∞–Ω–∂–µ–≤—ã–π)
        '#FF6666', // S (–ö—Ä–∞—Å–Ω—ã–π)
        '#CC33FF', // T (–§–∏–æ–ª–µ—Ç–æ–≤—ã–π)
        '#66FF66'  // Z (–ó–µ–ª–µ–Ω—ã–π)
    ];

    // –§–∏–≥—É—Ä—ã –¢–µ—Ç—Ä–∏—Å–∞
    const PIECES = {
        I: [
            [0, 0, 0, 0],
            [1, 1, 1, 1],
            [0, 0, 0, 0],
            [0, 0, 0, 0]
        ],
        J: [
            [2, 0, 0],
            [2, 2, 2],
            [0, 0, 0]
        ],
        L: [
            [0, 0, 3],
            [3, 3, 3],
            [0, 0, 0]
        ],
        O: [
            [4, 4],
            [4, 4]
        ],
        S: [
            [0, 5, 5],
            [5, 5, 0],
            [0, 0, 0]
        ],
        T: [
            [0, 6, 0],
            [6, 6, 6],
            [0, 0, 0]
        ],
        Z: [
            [7, 7, 0],
            [0, 7, 7],
            [0, 0, 0]
        ]
    };

    let board = createBoard();
    let piece = null;
    let nextPiece = null;
    let dropCounter = 0;
    let dropTime = 500;
    let lastTime = 0;
    let score = 0;
    let lines = 0;
    let level = 1;
    let gameStartTime = 0;
    let currentTime = 0;
    let lastLevel = 1;

    function createBoard() {
        return Array.from({length: ROWS}, () => Array(COLS).fill(0));
    }

    function createPiece() {
        const pieces = 'IJLOSTZ';
        const type = pieces[Math.floor(Math.random() * pieces.length)];
        return {
            pos: {x: Math.floor(COLS / 2) - 1, y: 0},
            matrix: JSON.parse(JSON.stringify(PIECES[type])),
            type: type
        };
    }

    function draw() {
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // --- –†–∏—Å—É–µ–º –≥–æ–ª–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫—É—é —Å–µ—Ç–∫—É ---
        ctx.strokeStyle = '#00ffff'; // –¶–∏–∞–Ω–æ–≤–∞—è —Å–µ—Ç–∫–∞
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.2; // –ü–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            }
        }
        ctx.globalAlpha = 1.0; // –°–±—Ä–æ—Å –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç–∏

        // –†–∏—Å—É–µ–º –±–ª–æ–∫–∏ –Ω–∞ –ø–æ–ª–µ
        for (let y = 0; y < ROWS; y++) {
            for (let x = 0; x < COLS; x++) {
                if (board[y][x]) {
                    drawBlock(x, y, board[y][x]);
                }
            }
        }

        // –†–∏—Å—É–µ–º —Ç–µ–∫—É—â—É—é —Ñ–∏–≥—É—Ä—É
        if (piece) {
            drawPiece(piece);
        }

        // --- –°—Ç–∏–ª—å–Ω—ã–π –≤—ã–≤–æ–¥ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ ---
        ctx.font = "bold 16px Orbitron";
        ctx.textAlign = "left";
        ctx.shadowColor = "#ff00ff";
        ctx.shadowBlur = 5;

        // –í—Ä–µ–º—è
        const minutes = Math.floor(currentTime / 60000);
        const seconds = Math.floor((currentTime % 60000) / 1000);
        const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        ctx.fillStyle = "#ff00ff";
        ctx.fillText("TIME: " + timeString, 10, 25);
        ctx.fillText("SCORE: " + score, 10, 50);
        ctx.fillText("LINES: " + lines, 10, 75);
        ctx.fillText("LEVEL: " + level, 10, 100);

        ctx.shadowBlur = 0; // –°–±—Ä–æ—Å —Ç–µ–Ω–∏
    }

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä–∏—Å–æ–≤–∞–Ω–∏—è –æ–¥–Ω–æ–≥–æ –±–ª–æ–∫–∞ —Å –Ω–µ–æ–Ω–æ–≤—ã–º —ç—Ñ—Ñ–µ–∫—Ç–æ–º
    function drawBlock(x, y, value) {
        const color = COLORS[value];

        // --- –ù–µ–æ–Ω–æ–≤–æ–µ —Å–≤–µ—á–µ–Ω–∏–µ ---
        ctx.shadowColor = color;
        ctx.shadowBlur = 15;

        ctx.fillStyle = color;
        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);

        // –í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —Ä–∞–º–∫–∞ –¥–ª—è –¥–µ—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ (–º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å –¥–ª—è —É–ª—å—Ç—Ä–∞-–º–∏–Ω–∏–º–∞–ª–∏–∑–º–∞)
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x * BLOCK_SIZE + 1, y * BLOCK_SIZE + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);

        ctx.shadowBlur = 0; // –°–±—Ä–æ—Å
    }

    function drawPiece(p) {
        p.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    drawBlock(p.pos.x + x, p.pos.y + y, value);
                }
            });
        });
    }

    function collide(board, piece) {
        const [m, o] = [piece.matrix, piece.pos];
        for (let y = 0; y < m.length; ++y) {
            for (let x = 0; x < m[y].length; ++x) {
                if (m[y][x] !== 0 &&
                   (board[y + o.y] === undefined ||
                    board[y + o.y][x + o.x] === undefined ||
                    board[y + o.y][x + o.x] !== 0)) {
                    return true;
                }
            }
        }
        return false;
    }

    function merge(board, piece) {
        piece.matrix.forEach((row, y) => {
            row.forEach((value, x) => {
                if (value !== 0) {
                    board[y + piece.pos.y][x + piece.pos.x] = value;
                }
            });
        });
    }

    function rotate(matrix) {
        const N = matrix.length;
        for (let i = 0; i < N; i++) {
            for (let j = i; j < N; j++) {
                [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];
            }
        }
        matrix.forEach(row => row.reverse());
    }

    function moveLeft() {
        if (!piece || !gameRunning) return;
        piece.pos.x--;
        if (collide(board, piece)) {
            piece.pos.x++;
        } else {
            playMoveSound();
        }
    }

    function moveRight() {
        if (!piece || !gameRunning) return;
        piece.pos.x++;
        if (collide(board, piece)) {
            piece.pos.x--;
        } else {
            playMoveSound();
        }
    }

    function moveDown() {
        if (!piece || !gameRunning) return;
        piece.pos.y++;
        if (collide(board, piece)) {
            piece.pos.y--;
            merge(board, piece);
            playDropSound();
            pieceReset();
            clearLines();
        }
        dropCounter = 0;
    }

    function rotatePiece() {
        if (!piece || !gameRunning) return;
        const pos = piece.pos.x;
        let offset = 1;
        const original = JSON.parse(JSON.stringify(piece.matrix));
        rotate(piece.matrix);

        while (collide(board, piece)) {
            piece.pos.x += offset;
            offset = -(offset + (offset > 0 ? 1 : -1));
            if (offset > piece.matrix[0].length) {
                piece.matrix = original;
                piece.pos.x = pos;
                return;
            }
        }
        playRotateSound();
    }

    function hardDrop() {
        if (!piece || !gameRunning) return;
        while (!collide(board, piece)) {
            piece.pos.y++;
        }
        piece.pos.y--;
        merge(board, piece);
        playDropSound();
        pieceReset();
        clearLines();
    }

    function pieceReset() {
        piece = nextPiece;
        nextPiece = createPiece();

        if (collide(board, piece)) {
            gameOver();
        }
    }

    function clearLines() {
        let linesCleared = 0;

        outer: for (let y = ROWS - 1; y >= 0; --y) {
            for (let x = 0; x < COLS; ++x) {
                if (board[y][x] === 0) {
                    continue outer;
                }
            }

            const row = board.splice(y, 1)[0].fill(0);
            board.unshift(row);
            ++y;
            linesCleared++;
        }

        if (linesCleared > 0) {
            const points = [0, 100, 300, 500, 800][linesCleared] * level;
            score += points;
            lines += linesCleared;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–≤—ã—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω—è
            const newLevel = Math.floor(lines / 10) + 1;
            if (newLevel > level) {
                level = newLevel;
                playLevelUpSound();
            } else {
                level = newLevel;
            }

            dropTime = Math.max(100, 500 - (level - 1) * 50);

            playLineClearSound(linesCleared);

            // –û–±–Ω–æ–≤–ª—è–µ–º –æ—á–∫–∏ –≤ –ø—Ä–æ—Ñ–∏–ª–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            let currentPoints = parseInt(localStorage.getItem("userPoints") || '0');
            localStorage.setItem("userPoints", currentPoints + linesCleared);

            sendToArduinoDisplay();
        }
    }

    function gameOver() {
        gameRunning = false;
        finalScoreElement.textContent = "FINAL SCORE: " + score;
        gameOverScreen.style.display = 'flex';
        playGameOverSound();
        sendGameOverToArduino();
    }

    function startTetris() {
        canvas.style.display = 'block';
        document.getElementById('placeholder-text').style.display = 'none';
        playButton.style.display = 'none';

        board = createBoard();
        piece = createPiece();
        nextPiece = createPiece();
        score = 0;
        lines = 0;
        level = 1;
        lastLevel = 1;
        dropTime = 500;
        gameRunning = true;
        gameOverScreen.style.display = 'none';
        gameStartTime = Date.now();
        currentTime = 0;

        sendReset();
        update();
    }

    function update(time = 0) {
        if (!gameRunning) return;

        const deltaTime = time - lastTime;
        lastTime = time;

        dropCounter += deltaTime;
        currentTime = Date.now() - gameStartTime;

        if (dropCounter > dropTime) {
            moveDown();
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –Ω–∞ Arduino –∫–∞–∂–¥—ã–µ 500–º—Å
        if (time % 500 < 16) {
            sendToArduinoDisplay();
        }

        draw();
        requestAnimationFrame(update);
    }

    // --- Arduino Logic ---

    async function connectToArduino() {
        if (!('serial' in navigator)) {
            statusDiv.textContent = '‚ö†Ô∏è WEB SERIAL API UNAVAILABLE.';
            return;
        }
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 115200 });
            const encoder = new TextEncoderStream();
            encoder.readable.pipeTo(port.writable);
            writer = encoder.writable.getWriter();

            const decoder = new TextDecoderStream();
            const readableStream = port.readable.pipeThrough(decoder);
            reader = readableStream.getReader();

            statusDiv.textContent = '‚úÖ ARDUINO PROTOCOL ACTIVE';
            document.getElementById('start-button').style.display = 'none';
            playButton.style.display = 'block';
            readArduinoData();
        } catch (error) {
            statusDiv.textContent = `[CONNECTION ERROR]: ${error.message}`;
        }
    }

    async function sendToArduinoDisplay() {
        if (!writer) return;

        const minutes = Math.floor(currentTime / 60000);
        const seconds = Math.floor((currentTime % 60000) / 1000);
        const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        // –§–æ—Ä–º–∞—Ç: TIME:MM:SS,SCORE:XXXX,LINES:XX,LEVEL:X
        const displayData = `TIME:${timeString},SCORE:${score},LINES:${lines},LEVEL:${level}\n`;
        await writer.write(displayData);
    }

    async function sendMoveSoundToArduino() {
        if (writer) await writer.write(`BUZZER_MOVE\n`);
    }

    async function sendRotateSoundToArduino() {
        if (writer) await writer.write(`BUZZER_ROTATE\n`);
    }

    async function sendDropSoundToArduino() {
        if (writer) await writer.write(`BUZZER_DROP\n`);
    }

    async function sendLineClearSoundToArduino(linesCleared) {
        if (writer) await writer.write(`BUZZER_LINE:${linesCleared}\n`);
    }

    async function sendLevelUpSoundToArduino() {
        if (writer) await writer.write(`BUZZER_LEVEL\n`);
    }

    async function sendGameOverToArduino() {
        if (writer) await writer.write(`BUZZER_LOSE\n`);
    }

    async function sendReset() {
        if (writer) await writer.write(`RESET\n`);
    }

    async function readArduinoData() {
        while (true) {
            const { value, done } = await reader.read();
            if (done) break;
            if (value) processInput(value.trim());
        }
    }

    function processInput(data) {
        const parts = data.split(',');
        if (parts.length < 3) return;
        const [joyX, joyY, button] = parts.map(Number);

        const LOW = 400, HIGH = 600;

        if (joyX < LOW) moveLeft();
        if (joyX > HIGH) moveRight();
        if (joyY < LOW) moveDown();
        if (button === 1) rotatePiece();

        statusDiv.textContent = `JOYSTICK INPUT: X=${joyX}, Y=${joyY}, BTN=${button}`;
    }

    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
    document.addEventListener('keydown', event => {
        if (!gameRunning) return;

        switch(event.keyCode) {
            case 37: moveLeft(); break;
            case 39: moveRight(); break;
            case 40: moveDown(); break;
            case 38: rotatePiece(); break;
            case 32: hardDrop(); break;
        }
    });

    document.getElementById('start-button').addEventListener('click', connectToArduino);
    playButton.addEventListener('click', startTetris);
    document.getElementById('restart-button').addEventListener('click', startTetris);
</script>
</body>
</html>